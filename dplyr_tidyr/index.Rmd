---
title: "Data wrangling in R"
author: "Julie Lowndes"
date: "July 12, 2016"
output: 
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Tidy Data

Hadley Wickham, RStudio's Chief Scientist, has been building R packages for data wrangling and visualization based on the idea of **tidy data**. Tidy data has a simple convention: put variables in the columns and observations in the rows.

![](img/tidy_data.png)

 **Our `gapminder` dataset is tidy data.**
 
We're going to continue wrangling this tidy data set, and then practice tidying untidy data. 

![](img/tidy_img.png) 

# Wrangling tidy data

We're going to continue in the transform part of the cycle, and then come back to tidying messy data once we've had some fun wrangling. 

![](img/r4ds_data-science.png)

Today we're going to learn about a package by Hadley Wickham called `dplyr` and how it will help you with simple data exploration, and how you can use it in combination with the `%>%` operator for more complex wrangling (including a lot of the things you would use `for` loops for). 

We'll do this in a new R script in the `software-carpentry` folder we created this morning. 

**Here's what to do:**

1. Open RStudio
1. Make sure you're in your `software-carpentry` repo (and if not, get there)
1. New File > R Script
1. Save as `gapminder-dplyr.r`
1. Our workflow together will be to write some description of our analysis in Markdown for humans to read, and we will write all of our R code in the 'chunks'. Get ready for the awesomeness, here we go...

Today's materials are again borrowing from some excellent sources, including

- Jenny Bryan's lectures from STAT545 at UBC: [Introduction to dplyr](http://stat545.com/block009_dplyr-intro.html)
- Hadley Wickham and Garrett Grolemund's [R for Data Science](http://r4ds.had.co.nz/)
- Software Carpentry's R for reproducible scientific analysis materials: [Dataframe manipulation with dplyr](http://swcarpentry.github.io/r-novice-gapminder/13-dplyr.html)
- First developed for [Software Carpentry at UCSB](http://remi-daigle.github.io/2016-04-15-UCSB/dplyr/)

# install our first package: `dplyr`

Packages are bundles of functions, along with help pages and other goodies that make them easier for others to use, (ie. vignettes). 

So far we've been using packages included in 'base R'; they are 'out-of-the-box' functions. You can also install packages from online. The most traditional is [CRAN, the Comprehensive R Archive Network](https://cran.r-project.org/). This is where you went to download R originally, and will go again to look for updates. 

You don't need to go to CRAN's website to install packages, we can do it from within R with the command `install.packages("package-name-in-quotes")`.
```{r}
## from CRAN:
#install.packages("dplyr") ## do this once only to install the package on your computer.

library(dplyr) ## do this every time you restart R and need it 
```
What's the difference between `install.packages()` and `library()`? Why do you need both? Here's my analogy: 

- `install.packages()` is setting up electricity for your house. Just need to do this once (let's ignore monthly bills). 
- `library()` is turning on the lights. You only turn them on when you need them, otherwise it wouldn't be efficient. And when you quit R, it turns the lights off, but the electricity lines are still there. So when you come back, you'll have to turn them on again with `library()`, but you already have your electricity set up.

# `dplyr` overview

There are five dplyr functions that you will use to do the vast majority of data manipulations:

- reorder the rows (`arrange()`),
- pick observations by their values (`filter()`),
- pick variables by their names (`select()`),
- create new variables with functions of existing variables (`mutate()`), or
- collapse many values down to a single summary (`summarise()`).

These can all be used in conjunction with `group_by()` which changes the scope of each function from operating on the entire dataset to operating on it group-by-group. These six functions provide the verbs for a language of data manipulation.

All verbs work similarly:

1. The first argument is a data frame.
2. The subsequent arguments describe what to do with the data frame. You can refer to columns in the data frame directly without using `$`.
3. The result is a new data frame.

Together these properties make it easy to chain together multiple simple steps to achieve a complex result.

# Use `dplyr::filter()` to subset data row-wise.

First let's read in the gapminder data. Earlier, we read in a `.csv` of the gapminder data. But Jenny Bryan has also released this as an R package, so you could also install it from CRAN and load it into as extra practice for loading packages.
```{r}
# install.packages('gapminder') # instead of reading in the csv
library(gapminder) # this is the package name
str(gapminder) # there's still a data frame named 'gapminder'
```

`filter()` takes logical expressions and returns the rows for which all are `TRUE`. Visually, we are doing this (thanks RStudio for your [cheatsheet](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)): 

![](img/rstudio-cheatsheet-filter.png)

```{r eval=FALSE}
filter(gapminder, lifeExp < 29)
filter(gapminder, country == "Mexico")
filter(gapminder, country %in% c("Mexico", "Afghanistan"))
```

Compare with some base R code to accomplish the same things
```{r eval = FALSE}
gapminder[gapminder$lifeExp < 29, ] ## repeat `gapminder`, [i, j] indexing is distracting
subset(gapminder, country == "Mexico") ## almost same as filter ... but wait ...
```

# Meet the new pipe operator

Before we go any further, we should exploit the new pipe operator that `dplyr` imports from the [`magrittr`](https://github.com/smbache/magrittr) package by Stefan Bache. **This is going to change your data analytical life**. You no longer need to enact multi-operation commands by nesting them inside each other. This new syntax leads to code that is much easier to write and to read.

Here's what it looks like: `%>%`. The RStudio keyboard shortcut: Ctrl + Shift + M (Windows), Cmd + Shift + M (Mac).

Let's demo then I'll explain:
```{r eval=FALSE}
gapminder %>% head
```

This is equivalent to `head(gapminder)`. This pipe operator takes the thing on the left-hand-side and __pipes__ it into the function call on the right-hand-side -- literally, drops it in as the first argument.

Never fear, you can still specify other arguments to this function! To see the first 3 rows of Gapminder, we could say `head(gapminder, 3)` or this:
```{r eval=FALSE}
gapminder %>% head(3)
```

**I've advised you to think "gets" whenever you see the assignment operator, `<-`. Similary, you should think "then" whenever you see the pipe operator, `%>%`.**

You are probably not impressed yet, but the magic will soon happen.

### Use `dplyr::select()` to subset the data on variables or columns.

Back to `dplyr` ...

Use `select()` to subset the data on variables or columns. Visually, we are doing this (thanks RStudio for your [cheatsheet](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)): 

![](img/rstudio-cheatsheet-select.png)

Here's a conventional call:

```{r eval=FALSE}
select(gapminder, year, lifeExp) 
```

But using what we just learned, with a pipe, we can do this:
```{r eval=FALSE}
gapminder %>% select(year, lifeExp)
```

Let's write it again but using multiple lines so it's nicer to read. And let's add a second pipe operator to pipe through `head`:
```{r}
gapminder %>%
  select(year, lifeExp) %>%
  head(4)
```
Think: "Take `gapminder`, then select the variables year and lifeExp, then show the first 4 rows."

# Revel in the convenience
Let's do a little analysis where we calculate the mean gdp for Cambodia. 

Here's the gapminder data for Cambodia, but only certain variables:
```{r, eval=FALSE}
gapminder %>%
  filter(country == "Cambodia") %>%
  # select(country, year, pop, gdpPercap) ## entering 4 of the 6 columns is tedious
  select(-continent, -lifeExp) # you can use - to deselect columns
```

and what a typical base R call would look like:

```{r, eval=FALSE}
gapminder[gapminder$country == "Cambodia", c("country", "year", "pop", "gdpPercap")]
```

or, possibly?, a nicer look using base R's `subset()` function:

```{r, eval=FALSE}
subset(gapminder, country == "Cambodia", select = c(country, year, pop, gdpPercap))
```

# Use `mutate()` to add new variables

Imagine we wanted to recover each country's GDP. After all, the Gapminder data has a variable for population and GDP per capita. Let's add a new column and multiply them together.

Visually, we are doing this (thanks RStudio for your [cheatsheet](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)): 

![](img/rstudio-cheatsheet-mutate.png)

```{r, eval=FALSE}
gapminder %>%
  mutate(gdp = pop * gdpPercap)
```

> Exercise: how would you add that to the previous `filter` and `select` commands we did with Cambodia:

```{r eval=FALSE}
gapminder %>%
  filter(country == "Cambodia") %>%
  select(-continent, -lifeExp)
```

Answer: 
```{r eval=FALSE}
gapminder %>%
  filter(country == "Cambodia") %>%
  select(-continent, -lifeExp) %>%
  mutate(gdp = pop * gdpPercap)
```

# `group_by` and `summarize`
Great! And now we want to calculate the mean gdp across all years (Let's pretend that's a good idea statistically) 

Visually, we are doing this (thanks RStudio for your [cheatsheet](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)): 
 
![](img/rstudio-cheatsheet-summarise.png)

```{r eval=FALSE}
gapminder %>%
  filter(country == "Cambodia") %>%
  select(-continent, -lifeExp) %>%
  mutate(gdp = pop * gdpPercap) %>%
  group_by(country) %>%
  summarize(mean_gdp = mean(gdp)) %>%
  ungroup() # if you use group_by, also use ungroup() to save heartache later
```

# Remember our for loop?

And how would you then do this for every country, not just Cambodia? Well, yesterday we would have been thinking about putting this whole analysis inside a for loop, replacing "Cambodia" with a new name each time we iterated through the loop. But today, we have it already, just need to *delete* one line from our analysis--we don't need to filter out Cambodia anymore!! 

Visually, we are doing this (thanks RStudio for your [cheatsheet](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)): 
 
![](img/rstudio-cheatsheet-group_by.png)

```{r eval=FALSE}
gapminder %>%
  select(-continent, -lifeExp) %>%
  mutate(gdp = pop * gdpPercap) %>%
  group_by(country) %>%
  summarize(mean_gdp = mean(gdp)) %>%
  ungroup() # if you use group_by, also use ungroup() to save heartache later
```

So we have done a pretty incredible amount of work in a few lines. Our whole analysis is this. Imagine the possibilities from here. It's very readable: you see the data as the first thing, it's not nested. Then, you can read the verbs

```{r eval=FALSE}
library(dplyr)
library(gapminder)

gapminder %>% 
  select(-continent, -lifeExp) %>%
  mutate(gdp = pop * gdpPercap) %>%
  group_by(country) %>%
  summarize(mean_gdp = mean(gdp)) %>%
  ungroup() # if you use group_by, also use ungroup() to save heartache later
```

> Exercise: with your neighbor, find the maximum life expectancy for countries in Asia. What is the earliest year you enounter? The latest? Hint: you can use or `base::max` and `dplyr::arrange()`...

```{r eval=FALSE}
## possible result--no peeking!!
gapminder %>%
  filter(continent == 'Asia') %>%
  group_by(country) %>%
  filter(lifeExp == max(lifeExp)) %>%
  arrange(desc(year))
```


# Tidying data

This has been the 'Tranform' or Wrangling part of this cycle. 

![](img/r4ds_data-science.png)

Importing and tidying is also a HUGE part of this process, so let's practice. Also, look at the cheatsheet, and watch the webinar. [cheatsheet](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf) and [webinar](https://www.rstudio.com/resources/webinars/data-wrangling-with-r-and-rstudio/). Watch this 1 hour webinar and follow along in RStudio and your science will be forever changed. Again!

## `tidyr` overview

Often, data must be reshaped for it to become tidy data. What does that mean? There are four main verbs we'll use, which are essentially pairs of opposites:

- turn rows into columns (`spread()`),
- turn columns into rows (`gather()`),
- turn a character column into multiple columns (`separate()`),
- turn multiple character columns into a single column (`unite()`)


You use `spread()` and `gather()` to transform or reshape data between 'wide' to 'long' formats. 'long' format is the tidy data we are after, where:

 - each column is a variable
 - each row is an observation

In the 'long' format, you usually have 1 column for the observed variable and the other columns are ID variables.

![](img/rstudio-cheatsheet-spread-gather.png)

For the 'wide' format each row is often a site/subject/patient and you have multiple observation variables containing the same type of data. These can be either repeated observations over time, or observation of multiple variables (or a mix of both). Data input may be simpler or some other applications may prefer the 'wide' format. However, many of `R`'s functions have been designed assuming you have 'long' format data. 

These data formats mainly affect readability. For humans, the wide format is often more intuitive since we can often see more of the data on the screen due to it's shape. However, the long format is more machine readable and is closer to the formating of databases. The ID variables in our dataframes are similar to the fields in a database and observed variables are like the database values.

## Getting started
First install the packages if you haven't already done so (you probably installed dplyr in the previous lesson):
```{r,eval=FALSE}
install.packages("tidyr")

```

Load the packages
```{r,message=FALSE}
library("tidyr")
library("dplyr")
```

First, lets look at the structure of our original gapminder dataframe:
```{r}
str(gapminder)
```

> ## Challenge 1 {.challenge}
>
> Is gapminder a purely long, purely wide, or some intermediate format?
>

Sometimes, as with the gapminder dataset, we have multiple types of observed data. It is somewhere in between the purely 'long' and 'wide' data formats. We have 3 "ID variables" (`continent`, `country`, `year`) and 3 "Observation variables" (`pop`,`lifeExp`,`gdpPercap`). I usually prefer my data in this intermediate format in most cases despite not having ALL observations in 1 column given that all 3 observation variables have different units. There are few operations that would need us to stretch out this dataframe any longer (i.e. 4 ID variables and 1 Observation variable).

While using many of the functions in R, which are often vector based, you usually do not want to do mathematical operations on values with different units. For example, using the purely long format, a single mean for all of the values of population, life expectancy, and GDP would not be meaningful since it would return the mean of values with 3 incompatible units. The solution is that we first manipulate the data either by grouping (see the lesson on `dplyr`), or we change the structure of the dataframe.
**Note:** Some plotting functions in R actually work better in the wide format data.

## From wide to long format with gather()
Until now, we've been using the nicely formatted original gapminder dataset, but 'real' data (i.e. our own research data) will never be so well organized. Here let's start with the wide format version of the gapminder dataset.

```{r}
str(gap_wide)
```

![](fig/14-tidyr-fig2.png)

The first step towards getting our nice intermediate data format is to first convert from the wide to the long format. The `tidyr` function `gather()` will 'gather' your observation variables into a single variable.

```{r}
gap_long <- gap_wide %>% gather(obstype_year,obs_values,starts_with('pop'),starts_with('lifeExp'),starts_with('gdpPercap'))
str(gap_long)
```

Here we have used piping syntax which is similar to what we were doing in the previous lesson with dplyr. In fact, these are compatible and you can use a mix of tidyr and dplyr functions by piping them together

Inside `gather()` we first name the new column for the new ID variable (`obstype_year`), the name for the new amalgamated observation variable (`obs_value`), then the names of the old observation variable. We could have typed out all the observation variables, but as in the `select()` function (see `dplyr` lesson), we can use the `starts_with()` argument to select all variables that starts with the desired character sring. Gather also allows the alternative syntax of using the `-` symbol to identify which variables are not to be gathered (i.e. ID variables)

![](fig/14-tidyr-fig3.png)

```{r}
gap_long <- gap_wide %>% gather(obstype_year,obs_values,-continent,-country)
str(gap_long)
```

That may seem trivial with this particular dataframe, but sometimes you have 1 ID variable and 40 Observation variables with irregular variables names. The flexibility is a huge time saver!


Now `obstype_year` actually contains 2 pieces of information, the observation type (`pop`,`lifeExp`, or `gdpPercap`) and the `year`. We can use the `separate()` function to split the character strings into multiple variables

```{r}
gap_long <- gap_long %>% separate(obstype_year,into=c('obs_type','year'),sep="_")
gap_long$year <- as.integer(gap_long$year)
```


> ## Challenge 2 {.challenge}
>
> Using `gap_long`, calculate the mean life expectancy, population, and gdpPercap for each continent.
>**Hint:** use the `group_by()` and `summarize()` functions we learned in the `dplyr` lesson
>

## From long to intermediate format with spread()
Now just to double-check our work, let's use the opposite of `gather()` to spread our observation variables back out with the aptly named `spread()`. We can then spread our `gap_long()` to the original intermediate format or the widest format. Let's start with the intermediate format.

```{r}
gap_normal <- gap_long %>% spread(obs_type,obs_values)
dim(gap_normal)
dim(gapminder)
names(gap_normal)
names(gapminder)
```

Now we've got an intermediate dataframe `gap_normal` with the same dimensions as the original `gapminder`, but the order of the variables is different. Let's fix that before checking if they are `all.equal()`.

```{r}
gap_normal <- gap_normal[,names(gapminder)]
all.equal(gap_normal,gapminder)
head(gap_normal)
head(gapminder)
```

We're almost there, the original was sorted by `country`, `continent`, then `year`.

```{r}
gap_normal <- gap_normal %>% arrange(country,continent,year)
all.equal(gap_normal,gapminder)
```

That's great! We've gone from the longest format back to the intermediate and we didn't introduce any errors in our code.

Now lets convert the long all the way back to the wide. In the wide format, we will keep country and continent as ID variables and spread the observations across the 3 metrics (`pop`,`lifeExp`,`gdpPercap`) and time (`year`). First we need to create appropriate labels for all our new variables (time*metric combinations) and we also need to unify our ID variables to simplify the process of defining `gap_wide`

```{r}
gap_temp <- gap_long %>% unite(var_ID,continent,country,sep="_")
str(gap_temp)

gap_temp <- gap_long %>%
    unite(ID_var,continent,country,sep="_") %>%
    unite(var_names,obs_type,year,sep="_")
str(gap_temp)
```

Using `unite()` we now have a single ID variable which is a combination of `continent`,`country`,and we have defined variable names. We're now ready to pipe in `spread()`  

```{r}
gap_wide_new <- gap_long %>% 
    unite(ID_var,continent,country,sep="_") %>%
    unite(var_names,obs_type,year,sep="_") %>%
    spread(var_names,obs_values)
str(gap_wide_new)
```

> ## Challenge 3 {.challenge}
>
> Take this 1 step further and create a `gap_ludicrously_wide` format data by spreading over countries, year and the 3 metrics?
>**Hint** this new dataframe should only have 5 rows.
>

Now we have a great 'wide' format dataframe, but the `ID_var` could be more usable, let's separate it into 2 variables with `separate()`


```{r}
gap_wide_betterID <- separate(gap_wide_new,ID_var,c("continent","country"),sep="_")
gap_wide_betterID <- gap_long %>% 
    unite(ID_var,continent,country,sep="_") %>%
    unite(var_names,obs_type,year,sep="_") %>%
    spread(var_names,obs_values) %>%
    separate(ID_var,c("continent","country"),sep="_")
str(gap_wide_betterID)

all.equal(gap_wide,gap_wide_betterID)
```

There and back again!

> ## Solution to Challenge 1 {.challenge}
>
> The original gapminder data.frame is in an intermediate format. It is not purely long since it had multiple observation variables (`pop`,`lifeExp`,`gdpPercap`).
>
>

> ## Solution to Challenge 2 {.challenge}
>```{r}
>gap_long %>% group_by(continent,obs_type) %>%
>    summarize(means=mean(obs_values))
>```

> ## Solution to Challenge 3 {.challenge}
>```{r}
>gap_ludicrously_wide <- gap_long %>% 
>    unite(var_names,obs_type,year,country,sep="_") %>%
>    spread(var_names,obs_values)
>```


## Other great resources
[Data Wrangling Cheat sheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)
[Introduction to tidyr](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html)	 


------

# Further materials as reference...

## Rationale 

When performing data analysis in R, code can become quite messy, making it hard to revisit and determine the sequence of operations. Commenting helps. Good variable names help. Still, at least two common issues make code difficult to understand: **multiple variables** and **nested functions**. Let's examine these issues by approaching an analysis presenting both problems, and finally see how `dplyr` offers an elegant alternative.

For example, let's ask of the `surveys.csv` dataset: _**How many observations of a certain thing you're interested in appear each year?**_

## Pseudocode

You can write the logic out as **pseudocode** which can become later comments for the actual code:

```{r pseudocode, eval=F}
# read in csv
# view data
# limit columns to species and year
# limit rows to just species "NL"
# get count per year
# write out csv
```

## Summary

The `tidyr` and `dplyr` packages were created by [Hadley Wickham](https://github.com/hadley) of `ggplot2` fame. The "gg" in `ggplot2` stands for the "grammar of graphics". Hadley similarly considers the functionality of the two packages `dplyr` and `tidyr` to provide the "grammar of data manipulation".

Tidy data has a simple convention: put variables in the columns and observations in the rows.

Next, we'll explore the data wrangling lessons that [Remi contributed](https://github.com/swcarpentry/r-novice-gapminder/commits?author=remi-daigle) to Software Carpentry.

We aren't going to focus on tidying data today, we're going to learn how to tranform, or wrangle, already-tidy data using the `dplyr` package. Importing and tidying is also a HUGE part of this process, and we don't have time to get into it today. But look at the [data wrangling cheatsheet](http://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf), and watch the 1-hour [data wrangling webinar](https://www.rstudio.com/resources/webinars/data-wrangling-with-r-and-rstudio/)--follow along in RStudio and your science will be forever changed. Again!


## `dplyr`

[**dplyr** - Software Carpentry](http://swcarpentry.github.io/r-novice-gapminder/13-dplyr.html)

## `tidyr`

[**tidyr** - Software Carpentry](http://swcarpentry.github.io/r-novice-gapminder/14-tidyr.html)


## Other links

* [Tidying up Data - Env Info](http://ucsb-bren.github.io/env-info/wk04_tidyr.html) - [Rmd](https://github.com/ucsb-bren/env-info/blob/gh-pages/wk04_tidyr.Rmd)
* [Data wrangling with dplyr and tidyr - Tyler Clavelle & Dan Ovando](http://bbest.github.io/dplyr-tidyr-tutorial/) - [Rmd](https://github.com/bbest/dplyr-tidyr-tutorial/blob/gh-pages/index.Rmd)
